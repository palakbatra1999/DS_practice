ğŸŒŸ LC 78 â€” Subsets (No Duplicates)
ğŸ§  Pattern: Backtracking / DFS / Include-Exclude
For each element, you have two choices:

Include it

Exclude it

You generate all 2^n subsets this way.

ğŸ”‘ Tips & Tricks:
âœ… No need to sort â€” elements are unique.

âœ… You can add the subset:

either at each call (ans.push_back(curr)) or

only when i == n (since all subsets are unique)

âœ¨ No need to handle duplicates â€” no check like if(nums[j] == nums[j-1])

ğŸ’­ Thinking Process:
Youâ€™re exploring all possible paths.

For every index, decide to take or skip it.

When you hit the end (base case), you have a valid subset.

You donâ€™t need to skip anything, because no two subsets will be the same.

ğŸ” LC 90 â€” Subsets II (With Duplicates)
ğŸ§  Pattern: Backtracking + Skip Duplicates
Still backtracking, but with extra care:

Use sorted input

Skip duplicates at the same recursion level

ğŸ”‘ Tips & Tricks:
âœ… Sort the array to bring duplicates together

ğŸš« Use:


if (j > i && nums[j] == nums[j - 1]) continue;
Skips picking the same number again at the same level

âœ… Push curr at every recursion call (not just at the base!)

âŒ No need for set â€” handle uniqueness with skip logic

ğŸ’­ Thinking Process:
You still make subsets like LC 78, butâ€¦

Now you have to think about whether including the same number again creates a duplicate subset.

You realize sorted input + skipping when nums[j] == nums[j - 1] ensures uniqueness.
